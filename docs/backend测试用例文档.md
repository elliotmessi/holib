# 医院药品管理系统后端测试用例文档

## 1. 文档概述

### 1.1 文档目的

本文档旨在为医院药品管理系统后端（NestJS v11）提供全面的测试用例设计指导。测试用例的设计基于系统需求文档、数据库表结构方案以及API接口文档，采用测试驱动开发（TDD）思想，确保代码质量的同时覆盖所有业务场景和边界条件。

本文档涵盖的测试范围包括身份认证与授权模块、字典管理模块、用户管理模块、角色权限管理模块、系统配置模块等核心功能模块。每个测试用例都包含测试目标、前置条件、测试步骤、预期结果以及边界条件说明，力求做到全面、准确、可执行。

### 1.2 测试框架与环境

后端项目使用Jest作为测试框架，Supertest作为HTTP请求测试工具，@nestjs/testing提供单元测试和集成测试支持。测试环境配置位于package.json的jest配置节中，测试文件命名规范为*.spec.ts，放置于src目录下与被测模块同级的位置。

```
测试配置文件位置：d:\projects\hospital\backend\package.json
测试根目录：d:\projects\hospital\backend\src
测试文件匹配规则：.*\.spec\.ts$
```

### 1.3 测试用例编写规范

测试用例遵循以下编写规范以确保测试质量和可维护性。每个测试用例应当包含清晰的测试描述，使用describe块组织相关测试用例，使用it或test函数定义具体的测试项。测试数据应具有代表性，能够覆盖正常流程、异常流程以及边界条件。测试用例之间应保持独立性，不应相互依赖。

## 2. 身份认证与授权模块测试用例

### 2.1 用户登录功能测试

用户登录是系统安全的第一道防线，登录功能的正确性直接关系到整个系统的安全性。本节测试用例覆盖正常登录、异常登录、账号锁定、验证码验证等多种场景，确保登录功能的健壮性和安全性。

#### 2.1.1 正常登录流程测试

**测试用例编号**：AUTH-LOGIN-001

**测试场景**：用户使用正确的用户名和密码登录系统

**前置条件**：系统中存在用户名为admin、密码为123456的账号，用户状态为启用，未被锁定，验证码有效且未过期

**测试步骤**：
1. 调用POST /api/v1/auth/login接口
2. 请求体包含username、password、captcha、captchaKey四个字段
3. username字段值为admin，password字段值为123456
4. captcha字段值为正确的验证码值，captchaKey字段值为有效的验证码密钥

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含accessToken和refreshToken两个令牌字段
- accessToken为JWT格式字符串，长度大于100字符
- refreshToken为JWT格式字符串，长度大于100字符
- 响应体中包含userInfo对象，包含userId、username、name、role等字段
- 用户登录失败次数重置为0
- 登录日志正确记录

**边界条件说明**：本测试用例关注的是理想情况下的登录流程，需要验证JWT令牌的正确性以及用户信息的完整性。测试时应确保Redis服务正常运行，因为登录成功后会向Redis写入令牌信息。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：AUTH-LOGIN-002

**测试场景**：用户使用正确的用户名、错误的密码登录

**前置条件**：系统中存在用户名为test的账号，密码为正确密码test123，用户状态为启用

**测试步骤**：
1. 调用POST /api/v1/auth/login接口
2. username字段值为test，password字段值为错误的密码wrongpassword

**预期结果**：
- 返回HTTP状态码401
- 响应体中code字段值为10001（用户名或密码错误）
- 响应体中message字段值包含密码错误提示信息
- 用户登录失败次数增加1次
- 登录日志记录本次失败登录

**边界条件说明**：需要验证连续错误登录后失败次数的累加是否正确，以及错误信息的返回是否明确但不过度暴露系统信息。密码输入时应测试特殊字符、空格等边界情况。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：AUTH-LOGIN-003

**测试场景**：用户使用不存在的用户名登录

**前置条件**：系统中不存在用户名为nonexistent的用户

**测试步骤**：
1. 调用POST /api/v1/auth/login接口
2. username字段值为nonexistent，password字段任意值

**预期结果**：
- 返回HTTP状态码401
- 响应体中code字段值为10001（用户名或密码错误）
- 错误信息提示用户名或密码错误，但不指明确切是用户名不存在还是密码错误（防止用户名枚举攻击）

**边界条件说明**：安全设计要求不能向客户端透露用户名是否存在的信息，因此无论是用户名不存在还是密码错误，都应返回相同的错误提示。测试时应验证这一安全特性是否正确实现。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：AUTH-LOGIN-004

**测试场景**：用户登录时验证码错误

**前置条件**：系统中存在有效用户，用户可以获取有效的验证码

**测试步骤**：
1. 调用POST /api/v1/auth/captcha接口获取验证码，获取captchaKey
2. 使用错误的captcha值（如将验证码数字1234改为5678）调用登录接口

**预期结果**：
- 返回HTTP状态码400
- 响应体中code字段值为10002（验证码错误）
- 错误信息明确提示验证码错误

**边界条件说明**：验证码是防止暴力破解的重要机制，测试时应验证验证码的大小写敏感性（如果有）、有效期限制、刷新机制等。还需要测试验证码在多次错误尝试后的处理逻辑。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：AUTH-LOGIN-005

**测试场景**：用户登录时验证码已过期

**前置条件**：系统中存在有效用户，可以获取验证码

**测试步骤**：
1. 调用POST /api/v1/auth/captcha接口获取验证码，获取captchaKey
2. 等待验证码过期（默认有效期2分钟）
3. 使用过期的验证码调用登录接口

**预期结果**：
- 返回HTTP状态码400或401
- 响应体中code字段值应为10002（验证码错误）或类似错误码
- 错误信息提示验证码已过期或无效

**边界条件说明**：验证码的有效期配置在系统参数中，测试时应验证配置是否生效。过期的验证码应当被正确识别和拒绝，不能因为验证码过期而允许通过。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：AUTH-LOGIN-006

**测试场景**：账号连续登录失败达到锁定阈值

**前置条件**：系统中存在用户名为locktest的账号，登录失败次数限制为5次

**测试步骤**：
1. 使用错误的密码连续登录6次
2. 每次登录后等待1秒确保失败次数被记录

**预期结果**：
- 前5次登录返回401错误码，失败次数递增
- 第6次登录返回HTTP状态码401或403
- 响应体中code字段值为10003（账号已锁定）或类似错误码
- 用户账号状态变为锁定或失败次数达到上限
- 错误信息提示账号已被锁定

**边界条件说明**：账号锁定机制是防止暴力破解的关键。测试时应验证锁定时间的配置是否生效，解锁后是否能够正常登录。还需要测试锁定期间使用正确密码登录是否也会被拒绝。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：AUTH-LOGIN-007

**测试场景**：已禁用账号尝试登录

**前置条件**：系统中存在用户名为disabled的账号，该账号状态为禁用（inactive或disabled）

**测试步骤**：
1. 调用POST /api/v1/auth/login接口
2. username字段值为disabled，password字段为该账号的正确密码

**预期结果**：
- 返回HTTP状态码401或403
- 错误信息提示账号已被禁用
- 明确告知用户账号状态而非提示密码错误

**边界条件说明**：禁用账号的登录尝试应当被明确拒绝，且错误信息应当清晰说明账号状态。但同时也要注意信息泄露问题，不应暴露过多账号状态信息。

**测试优先级**：P1（重要功能，应覆盖）

### 2.2 Token刷新功能测试

Token刷新功能允许用户在访问令牌过期前获取新的访问令牌，保证用户会话的连续性而不需要重新输入密码。

#### 2.2.1 正常Token刷新测试

**测试用例编号**：AUTH-REFRESH-001

**测试场景**：使用有效的refreshToken获取新的accessToken

**前置条件**：用户已成功登录，获取到有效的accessToken和refreshToken

**测试步骤**：
1. 调用POST /api/v1/auth/refresh-token接口
2. 请求体中包含有效的refreshToken字段

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含新的accessToken字段
- 新的accessToken与原accessToken不同
- 新的accessToken有效期正确

**边界条件说明**：刷新令牌后，原访问令牌应当被加入黑名单或失效，以防止令牌重用攻击。测试时应验证旧令牌在新令牌获取后是否仍然有效。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：AUTH-REFRESH-002

**测试场景**：使用过期的refreshToken获取新的accessToken

**前置条件**：用户已登录，但refreshToken已过期

**测试步骤**：
1. 获取一个过期的refreshToken（可以通过修改系统时间或等待refreshToken自然过期）
2. 调用POST /api/v1/auth/refresh-token接口，使用过期的refreshToken

**预期结果**：
- 返回HTTP状态码401
- 错误信息提示refreshToken已过期或无效
- 不能生成新的accessToken

**边界条件说明**：过期的refreshToken应当被正确拒绝，不能生成新的访问令牌。这要求系统正确验证JWT令牌的过期时间。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：AUTH-REFRESH-003

**测试场景**：使用无效的refreshToken格式获取新的accessToken

**前置条件**：用户已登录

**测试步骤**：
1. 调用POST /api/v1/auth/refresh-token接口
2. 请求体中包含格式错误的refreshToken（如空字符串、纯文本等）

**预期结果**：
- 返回HTTP状态码401
- 错误信息提示令牌无效
- 不能生成新的accessToken

**边界条件说明**：系统应当能够识别无效的JWT格式，防止格式错误的令牌导致系统异常。

**测试优先级**：P1（重要功能，应覆盖）

### 2.3 用户登出功能测试

用户登出功能用于清除用户的登录状态，确保用户会话被正确终止。

#### 2.3.1 正常登出测试

**测试用例编号**：AUTH-LOGOUT-001

**测试场景**：用户成功登出系统

**前置条件**：用户已成功登录，获取到有效的accessToken

**测试步骤**：
1. 调用POST /api/v1/auth/logout接口
2. 请求头中携带有效的Authorization Bearer Token

**预期结果**：
- 返回HTTP状态码200或成功标志
- 用户的Redis中存储的token被删除或加入黑名单
- 用户的权限缓存被清除
- 登出日志被正确记录

**边界条件说明**：登出后应确保用户无法继续使用之前的token访问受保护资源。测试时应验证token在登出后是否仍然有效。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：AUTH-LOGOUT-002

**测试场景**：未登录用户尝试登出

**前置条件**：用户未登录或token已过期

**测试步骤**：
1. 调用POST /api/v1/auth/logout接口
2. 不携带Authorization头或使用无效的token

**预期结果**：
- 返回HTTP状态码401
- 错误信息提示未授权

**边界条件说明**：系统应当正确拒绝未授权用户的登出请求，不能因为是登出操作而允许未授权访问。

**测试优先级**：P2（一般功能，建议覆盖）

## 3. 字典管理模块测试用例

字典管理模块是系统的基础数据管理模块，包括字典类型管理和字典项管理两个子模块。字典数据在系统中广泛使用，其正确性直接影响业务功能的正常运行。

### 3.1 字典类型管理测试

字典类型用于对字典项进行分类管理，每个字典类型下可以包含多个字典项。

#### 3.1.1 创建字典类型测试

**测试用例编号**：DICT-TYPE-CREATE-001

**测试场景**：正常创建字典类型

**前置条件**：当前用户具有创建字典类型的权限，系统中不存在编码为drug_type的字典类型

**测试步骤**：
1. 调用POST /api/v1/dict-types接口
2. 请求体包含dictTypeCode（drug_type）、dictTypeName（药品类型）、description（药品的类型分类）
3. 设置status为active，sortOrder为0

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含新创建的字典类型完整信息
- dictTypeCode字段值为drug_type
- dictTypeName字段值为药品类型
- status字段值为active
- 数据库中正确插入一条字典类型记录

**边界条件说明**：创建时需要验证必填字段的校验，包括dictTypeCode的唯一性约束、dictTypeName的长度限制等。测试数据应覆盖字段长度边界的最大值和最小值。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-CREATE-002

**测试场景**：创建字典类型时编码重复

**前置条件**：系统中已存在编码为duplicate_type的字典类型

**测试步骤**：
1. 调用POST /api/v1/dict-types接口
2. dictTypeCode字段值为duplicate_type（与已存在的字典类型编码相同）

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误码50001（字典类型已存在）或类似错误码
- 错误信息明确提示编码已存在
- 数据库中没有新增记录

**边界条件说明**：字典类型编码的唯一性约束应当严格执行，不能因为重复编码而导致数据异常。测试时应验证错误码和错误信息是否符合API文档规范。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-CREATE-003

**测试场景**：创建字典类型时缺少必填字段

**前置条件**：当前用户具有创建字典类型的权限

**测试步骤**：
1. 调用POST /api/v1/dict-types接口
2. 只提供dictTypeName字段，缺少dictTypeCode字段

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含字段校验错误信息
- 错误信息指出dictTypeCode字段为必填
- 数据库中没有新增记录

**边界条件说明**：必填字段的校验应当在数据持久化之前完成，使用class-validator进行参数校验。测试时应覆盖所有必填字段缺失的情况。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DICT-TYPE-CREATE-004

**测试场景**：创建字典类型时字段长度超限

**前置条件**：当前用户具有创建字典类型的权限

**测试步骤**：
1. 调用POST /api/v1/dict-types接口
2. dictTypeCode字段值设置为超过数据库定义长度的字符串（如100个字符）
3. dictTypeName字段值设置为超过定义长度的字符串

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含字段长度校验错误信息
- 错误信息明确指出超限的字段
- 数据库中没有新增记录

**边界条件说明**：根据数据库设计，dictTypeCode长度为50字符，dictTypeName长度为100字符。测试时应验证边界值（51、100、101字符）时的处理情况。

**测试优先级**：P1（重要功能，应覆盖）

#### 3.1.2 查询字典类型测试

**测试用例编号**：DICT-TYPE-QUERY-001

**测试场景**：分页查询字典类型列表

**前置条件**：系统中存在多条字典类型记录（至少25条）

**测试步骤**：
1. 调用GET /api/v1/dict-types接口
2. 不传任何参数，使用默认分页参数（page=1，pageSize=20）

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含total、page、pageSize、list字段
- total字段值为字典类型总记录数
- list字段值为数组，长度不超过pageSize（20）
- list中的每条记录包含dictTypeId、dictTypeCode、dictTypeName等字段

**边界条件说明**：分页查询需要验证total计算是否正确，page和pageSize参数的处理是否正确。测试时应覆盖第一页、最后一页、中间页等情况。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-QUERY-002

**测试场景**：分页查询时指定page和pageSize

**前置条件**：系统中存在多条字典类型记录

**测试步骤**：
1. 调用GET /api/v1/dict-types接口
2. 设置page=2，pageSize=10

**预期结果**：
- 返回HTTP状态码200
- page字段值为2
- pageSize字段值为10
- list长度为10（假设总记录数大于20）
- 返回的数据与第一页数据不重复

**边界条件说明**：分页参数应当被正确处理，包括page小于1、page大于总页数、pageSize小于1、pageSize大于最大限制等边界情况。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DICT-TYPE-QUERY-003

**测试场景**：按名称模糊查询字典类型

**前置条件**：系统中存在名称包含"药品"的字典类型

**测试步骤**：
1. 调用GET /api/v1/dict-types接口
2. 设置name参数为"药品"

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的dictTypeName都包含"药品"关键词
- total字段值为匹配记录的总数

**边界条件说明**：模糊查询应使用SQL的LIKE语句实现，测试时应验证大小写敏感性（如果数据库不区分大小写则不需要）、特殊字符处理等情况。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DICT-TYPE-QUERY-004

**测试场景**：按编码精确查询字典类型

**前置条件**：系统中存在编码为test_type的字典类型

**测试步骤**：
1. 调用GET /api/v1/dict-types接口
2. 设置code参数为test_type

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的dictTypeCode都等于test_type（可能有多条，如果存在同名情况但根据唯一性约束应只有一条）
- total字段值为匹配记录数

**边界条件说明**：精确查询应使用SQL的等值匹配，测试时应验证编码不存在时的返回结果。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DICT-TYPE-QUERY-005

**测试场景**：组合条件查询字典类型

**前置条件**：系统中存在多条字典类型记录

**测试步骤**：
1. 调用GET /api/v1/dict-types接口
2. 同时设置name和code参数进行筛选

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录同时满足name和code的筛选条件
- total字段值为同时满足两个条件的记录数

**边界条件说明**：组合条件查询需要验证AND逻辑是否正确执行。测试时应验证任意条件为空时的处理情况。

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：DICT-TYPE-QUERY-006

**测试场景**：查询不存在的字典类型ID

**前置条件**：系统中不存在ID为99999的字典类型

**测试步骤**：
1. 调用GET /api/v1/dict-types/99999接口

**预期结果**：
- 返回HTTP状态码404
- 响应体中包含错误信息提示资源不存在

**边界条件说明**：单个资源查询应当返回404状态码，测试时应验证ID格式错误（如非数字）时的处理情况。

**测试优先级**：P1（重要功能，应覆盖）

#### 3.1.3 更新字典类型测试

**测试用例编号**：DICT-TYPE-UPDATE-001

**测试场景**：正常更新字典类型

**前置条件**：系统中存在ID为1的字典类型

**测试步骤**：
1. 调用PUT /api/v1/dict-types/1接口
2. 请求体包含dictTypeName（更新的名称）、description（更新的描述）

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含更新后的字典类型信息
- 数据库中对应记录的dictTypeName和description字段被更新
- updatedAt字段被更新为当前时间

**边界条件说明**：更新操作应当只更新传入的字段，未传入的字段应保持不变。测试时应验证updatedAt是否自动更新。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-UPDATE-002

**测试场景**：更新字典类型时编码重复

**前置条件**：系统中存在ID为1和ID为2的两个字典类型，编码分别为type1和type2

**测试步骤**：
1. 调用PUT /api/v1/dict-types/2接口
2. 请求体中设置dictTypeCode为type1

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误码50001（字典类型已存在）或类似错误码
- ID为2的字典类型的编码保持为type2未被修改

**边界条件说明**：更新时的唯一性校验应当排除自身，即更新时不应当因为自身编码未改变而报错。测试时应验证这种情况的正确处理。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-UPDATE-003

**测试场景**：更新不存在的字典类型

**前置条件**：系统中不存在ID为99999的字典类型

**测试步骤**：
1. 调用PUT /api/v1/dict-types/99999接口
2. 请求体包含任意更新数据

**预期结果**：
- 返回HTTP状态码404
- 错误信息提示资源不存在

**边界条件说明**：更新不存在的资源应当返回404状态码，不能返回200成功。

**测试优先级**：P1（重要功能，应覆盖）

#### 3.1.4 删除字典类型测试

**测试用例编号**：DICT-TYPE-DELETE-001

**测试场景**：正常删除字典类型

**前置条件**：系统中存在ID为100的字典类型，该类型下没有字典项

**测试步骤**：
1. 调用DELETE /api/v1/dict-types/100接口

**预期结果**：
- 返回HTTP状态码200或204
- 数据库中该字典类型记录被删除
- 返回成功标志

**边界条件说明**：删除操作应当从数据库中物理删除或标记删除（根据系统设计）。测试时应验证删除后的数据确实不存在。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-DELETE-002

**测试场景**：删除字典类型时存在关联字典项

**前置条件**：系统中存在ID为1的字典类型，该类型下存在至少一条字典项

**测试步骤**：
1. 调用DELETE /api/v1/dict-types/1接口

**预期结果**：
- 返回HTTP状态码400或409
- 响应体中包含错误信息提示存在关联数据
- 字典类型记录未被删除
- 关联的字典项记录未被删除

**边界条件说明**：根据数据库外键约束设计，字典项表通过dict_type_id关联字典类型表。删除字典类型前应当检查是否存在关联的字典项，如果存在则应当阻止删除并返回明确的错误信息。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-TYPE-DELETE-003

**测试场景**：删除不存在的字典类型

**前置条件**：系统中不存在ID为99999的字典类型

**测试步骤**：
1. 调用DELETE /api/v1/dict-types/99999接口

**预期结果**：
- 返回HTTP状态码404
- 错误信息提示资源不存在

**边界条件说明**：删除不存在的资源应当返回404状态码。

**测试优先级**：P1（重要功能，应覆盖）

### 3.2 字典项管理测试

字典项是字典类型的具体数据项，每个字典项归属于一个字典类型。

#### 3.2.1 创建字典项测试

**测试用例编号**：DICT-ITEM-CREATE-001

**测试场景**：正常创建字典项

**前置条件**：系统中存在ID为1的字典类型，不存在编码为chinese_medicine的字典项

**测试步骤**：
1. 调用POST /api/v1/dict-items接口
2. 请求体包含typeId（1）、dictItemCode（chinese_medicine）、dictItemName（中药）、dictItemValue（chinese）、status（active）、sortOrder（0）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含新创建的字典项完整信息
- dictItemCode字段值为chinese_medicine
- dictItemName字段值为中药
- 数据库中正确插入一条字典项记录
- type字段正确关联到ID为1的字典类型

**边界条件说明**：创建时需要验证与字典类型的关联关系是否正确建立，以及字典项编码在字典类型下的唯一性约束。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-ITEM-CREATE-002

**测试场景**：创建字典项时同一类型下编码重复

**前置条件**：系统中存在ID为1的字典类型，该类型下已存在编码为western_medicine的字典项

**测试步骤**：
1. 调用POST /api/v1/dict-items接口
2. typeId设置为1，dictItemCode设置为western_medicine（与已存在的字典项编码相同）

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误码50002（字典项已存在）或类似错误码
- 数据库中没有新增记录

**边界条件说明**：字典项编码在同一个字典类型下应当唯一，但不同字典类型下可以有相同编码的字典项。测试时应验证这一约束。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-ITEM-CREATE-003

**测试场景**：创建字典项时关联不存在的字典类型

**前置条件**：系统中不存在ID为99999的字典类型

**测试步骤**：
1. 调用POST /api/v1/dict-items接口
2. typeId设置为99999，其他字段为有效数据

**预期结果**：
- 返回HTTP状态码400或404
- 响应体中包含错误信息提示字典类型不存在
- 数据库中没有新增记录

**边界条件说明**：字典项必须关联一个存在的字典类型，系统应当在数据持久化前验证typeId的有效性。

**测试优先级**：P1（重要功能，应覆盖）

#### 3.2.2 查询字典项测试

**测试用例编号**：DICT-ITEM-QUERY-001

**测试场景**：按字典类型查询字典项

**前置条件**：系统中存在ID为1的字典类型，该类型下存在多条字典项

**测试步骤**：
1. 调用GET /api/v1/dict-items/by-type/drug_type接口（使用字典类型编码）

**预期结果**：
- 返回HTTP状态码200
- 响应体为数组，包含该类型下所有字典项
- 每条字典项记录包含dictItemId、dictItemCode、dictItemName、dictItemValue等字段
- 字典项按sortOrder字段升序排列

**边界条件说明**：按类型查询是字典项最常用的查询场景，需要验证排序是否正确以及关联的字典类型信息是否包含。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DICT-ITEM-QUERY-002

**测试场景**：分页查询字典项列表

**前置条件**：系统中存在多条字典项记录

**测试步骤**：
1. 调用GET /api/v1/dict-items接口
2. 设置page=1，pageSize=10，typeId=1

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含total、page、pageSize、list字段
- list中每条记录关联的字典类型ID为1
- total字段值为该类型下字典项总数

**边界条件说明**：分页查询需要验证typeId筛选条件是否正确应用，以及total计算是否准确。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DICT-ITEM-QUERY-003

**测试场景**：按标签模糊查询字典项

**前置条件**：系统中存在标签包含"药"的字典项

**测试步骤**：
1. 调用GET /api/v1/dict-items接口
2. 设置label参数为"药"

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的dictItemName都包含"药"关键词
- total字段值为匹配记录数

**边界条件说明**：模糊查询应使用SQL的LIKE语句实现，支持%通配符语义。

**测试优先级**：P2（一般功能，建议覆盖）

#### 3.2.3 更新和删除字典项测试

**测试用例编号**：DICT-ITEM-UPDATE-001

**测试场景**：正常更新字典项

**前置条件**：系统中存在ID为1的字典项

**测试步骤**：
1. 调用PUT /api/v1/dict-items/1接口
2. 请求体包含dictItemName（更新后的名称）、sortOrder（更新后的排序）

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含更新后的字典项信息
- 数据库中对应记录的dictItemName和sortOrder字段被更新

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DICT-ITEM-DELETE-001

**测试场景**：正常删除字典项

**前置条件**：系统中存在ID为100的字典项

**测试步骤**：
1. 调用DELETE /api/v1/dict-items/100接口

**预期结果**：
- 返回HTTP状态码200或204
- 数据库中该字典项记录被删除

**测试优先级**：P1（重要功能，应覆盖）

## 4. 用户管理模块测试用例

用户管理模块负责系统中用户账号的创建、查询、更新和删除操作。用户是系统的主体，所有的业务操作都需要通过用户身份来执行。

### 4.1 用户创建测试

#### 4.1.1 正常创建用户测试

**测试用例编号**：USER-CREATE-001

**测试场景**：正常创建新用户

**前置条件**：当前操作用户具有创建用户的权限，系统中不存在用户名testuser的用户

**测试步骤**：
1. 调用POST /api/v1/users接口
2. 请求体包含username（testuser）、password（Test123456）、name（测试用户）、email（test@example.com）、phone（13800138000）、status（active）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含新创建用户的完整信息（密码字段应被屏蔽）
- username字段值为testuser
- status字段值为active
- 数据库中正确插入用户记录
- 密码字段被加密存储（不是明文）

**边界条件说明**：用户创建时需要验证密码复杂度要求（根据需求文档，密码应包含大小写字母、数字、特殊字符等），测试时应覆盖密码不符合复杂度要求的情况。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：USER-CREATE-002

**测试场景**：创建用户时用户名重复

**前置条件**：系统中已存在用户名为admin的用户

**测试步骤**：
1. 调用POST /api/v1/users接口
2. username字段值设置为admin

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误信息提示用户名已存在
- 数据库中没有新增用户记录

**边界条件说明**：用户名的唯一性约束是用户系统的基本要求，系统应当严格执行这一约束。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：USER-CREATE-003

**测试场景**：创建用户时邮箱重复

**前置条件**：系统中已存在邮箱为admin@example.com的用户

**测试步骤**：
1. 调用POST /api/v1/users接口
2. email字段值设置为admin@example.com

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误信息提示邮箱已被使用
- 数据库中没有新增用户记录

**边界条件说明**：邮箱通常作为用户找回密码的凭证，需要保证唯一性。测试时应验证邮箱格式校验是否正确。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-CREATE-004

**测试场景**：创建用户时密码不符合复杂度要求

**前置条件**：当前操作用户具有创建用户的权限

**测试步骤**：
1. 调用POST /api/v1/users接口
2. password字段值设置为简单密码（如123456或aaaaaa）

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含密码复杂度校验错误信息
- 数据库中没有新增用户记录

**边界条件说明**：密码复杂度要求应符合安全标准，通常要求至少8位，包含大小写字母、数字和特殊字符。测试时应覆盖各种不符合要求的情况。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-CREATE-005

**测试场景**：创建用户时邮箱格式错误

**前置条件**：当前操作用户具有创建用户的权限

**测试步骤**：
1. 调用POST /api/v1/users接口
2. email字段值设置为无效邮箱格式（如testexample.com或test@）

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含邮箱格式校验错误信息
- 数据库中没有新增用户记录

**边界条件说明**：邮箱格式校验应使用正则表达式验证，测试时应覆盖各种无效格式。

**测试优先级**：P1（重要功能，应覆盖）

### 4.2 用户查询测试

#### 4.2.1 分页查询用户测试

**测试用例编号**：USER-QUERY-001

**测试场景**：分页查询用户列表

**前置条件**：系统中存在多条用户记录

**测试步骤**：
1. 调用GET /api/v1/users接口
2. 不传参数，使用默认分页

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含total、page、pageSize、list字段
- list中每条用户记录不包含password字段
- total字段值为用户总记录数

**边界条件说明**：用户列表查询不应返回敏感信息（如密码），测试时应验证密码字段确实被排除在响应外。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：USER-QUERY-002

**测试场景**：按用户名模糊查询用户

**前置条件**：系统中存在用户名包含"admin"的用户

**测试步骤**：
1. 调用GET /api/v1/users接口
2. 设置keyword参数为"admin"

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的用户名都包含"admin"关键词

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-QUERY-003

**测试场景**：按部门筛选用户

**前置条件**：系统中存在多个部门的用户，部门ID为1的部门下有用户

**测试步骤**：
1. 调用GET /api/v1/users接口
2. 设置filter参数为departmentId:eq:1

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的departmentId都为1

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-QUERY-004

**测试场景**：查询单个用户详情

**前置条件**：系统中存在ID为1的用户

**测试步骤**：
1. 调用GET /api/v1/users/1接口

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含该用户的完整信息
- 不包含password字段
- 包含关联的部门信息、角色信息等

**测试优先级**：P1（重要功能，应覆盖）

### 4.3 用户更新测试

#### 4.3.1 正常更新用户测试

**测试用例编号**：USER-UPDATE-001

**测试场景**：更新用户基本信息

**前置条件**：系统中存在ID为1的用户

**测试步骤**：
1. 调用PUT /api/v1/users/1接口
2. 请求体包含name（更新后的姓名）、phone（更新后的手机号）

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含更新后的用户信息
- 数据库中对应记录被更新
- updatedAt字段被更新

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-UPDATE-002

**测试场景**：更新用户状态为禁用

**前置条件**：系统中存在ID为1的用户，状态为active

**测试步骤**：
1. 调用PUT /api/v1/users/1接口
2. 请求体包含status（inactive）

**预期结果**：
- 返回HTTP状态码200
- 用户状态变为inactive
- 该用户无法再登录系统

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-UPDATE-003

**测试场景**：更新不存在的用户

**前置条件**：系统中不存在ID为99999的用户

**测试步骤**：
1. 调用PUT /api/v1/users/99999接口
2. 请求体包含任意更新数据

**预期结果**：
- 返回HTTP状态码404
- 错误信息提示用户不存在

**测试优先级**：P1（重要功能，应覆盖）

### 4.4 用户删除测试

#### 4.4.1 正常删除用户测试

**测试用例编号**：USER-DELETE-001

**测试场景**：正常删除用户

**前置条件**：系统中存在ID为100的用户，该用户未被其他数据关联

**测试步骤**：
1. 调用DELETE /api/v1/users/100接口

**预期结果**：
- 返回HTTP状态码200或204
- 数据库中该用户记录被删除
- 该用户无法再登录系统

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-DELETE-002

**测试场景**：删除用户时存在关联数据

**前置条件**：系统中存在ID为1的管理员用户，该用户关联了角色、登录日志等数据

**测试步骤**：
1. 调用DELETE /api/v1/users/1接口

**预期结果**：
- 返回HTTP状态码400或409
- 错误信息提示存在关联数据
- 用户记录未被删除

**边界条件说明**：删除用户前应检查是否存在关联数据，如处方记录、操作日志等。根据业务需求，可能需要采用逻辑删除而非物理删除。

**测试优先级**：P1（重要功能，应覆盖）

## 5. 角色权限管理模块测试用例

角色权限管理模块实现基于角色的访问控制（RBAC），包括角色管理、权限管理和用户角色关联管理。

### 5.1 角色管理测试

#### 5.1.1 创建角色测试

**测试用例编号**：ROLE-CREATE-001

**测试场景**：正常创建角色

**前置条件**：当前用户具有创建角色的权限，系统中不存在编码为custom_role的角色

**测试步骤**：
1. 调用POST /api/v1/roles接口
2. 请求体包含roleCode（custom_role）、name（自定义角色）、description（自定义描述）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含新创建角色的完整信息
- roleCode字段值为custom_role
- 数据库中正确插入角色记录

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：ROLE-CREATE-002

**测试场景**：创建角色时编码重复

**前置条件**：系统中已存在编码为admin的角色

**测试步骤**：
1. 调用POST /api/v1/roles接口
2. roleCode字段值设置为admin

**预期结果**：
- 返回HTTP状态码400
- 错误信息提示角色编码已存在
- 数据库中没有新增记录

**测试优先级**：P1（重要功能，应覆盖）

### 5.2 权限分配测试

#### 5.2.1 为角色分配权限测试

**测试用例编号**：ROLE-PERMISSION-001

**测试场景**：为角色分配权限

**前置条件**：系统中存在ID为1的角色，存在ID为1、2、3的权限

**测试步骤**：
1. 调用POST /api/v1/roles/1/permissions接口
2. 请求体包含permissionIds数组[1, 2, 3]

**预期结果**：
- 返回HTTP状态码200
- 角色权限关联表中新增三条记录
- 角色现在拥有这三个权限

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：ROLE-PERMISSION-002

**测试场景**：为角色分配不存在的权限

**前置条件**：系统中存在ID为1的角色，不存在ID为99999的权限

**测试步骤**：
1. 调用POST /api/v1/roles/1/permissions接口
2. 请求体包含permissionIds数组[99999]

**预期结果**：
- 返回HTTP状态码400或404
- 错误信息提示权限不存在
- 角色权限关联表没有新增记录

**测试优先级**：P1（重要功能，应覆盖）

### 5.3 用户角色关联测试

#### 5.3.1 为用户分配角色测试

**测试用例编号**：USER-ROLE-001

**测试场景**：为用户分配角色

**前置条件**：系统中存在ID为1的用户，存在ID为2的角色

**测试步骤**：
1. 调用POST /api/v1/users/1/roles接口
2. 请求体包含roleIds数组[2]

**预期结果**：
- 返回HTTP状态码200
- 用户角色关联表中新增记录
- 用户现在拥有角色2的权限

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-ROLE-002

**测试场景**：用户拥有多个角色

**前置条件**：系统中存在ID为1的用户，该用户已被分配角色2

**测试步骤**：
1. 调用POST /api/v1/users/1/roles接口
2. 请求体包含roleIds数组[2, 3]

**预期结果**：
- 返回HTTP状态码200
- 用户角色关联表中新增角色3的记录
- 用户现在同时拥有角色2和角色3的权限
- 权限取并集

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：USER-ROLE-003

**测试场景**：移除用户角色

**前置条件**：系统中存在ID为1的用户，该用户拥有角色2和角色3

**测试步骤**：
1. 调用PUT /api/v1/users/1/roles接口
2. 请求体包含roleIds数组[2]（只保留角色2）

**预期结果**：
- 返回HTTP状态码200
- 用户角色关联表中角色3的记录被删除
- 用户现在只拥有角色2的权限

**测试优先级**：P1（重要功能，应覆盖）

## 6. 系统配置模块测试用例

系统配置模块负责管理系统级别的参数配置，包括参数配置查询、更新等操作。

### 6.1 参数配置查询测试

#### 6.1.1 查询参数配置列表测试

**测试用例编号**：PARAM-QUERY-001

**测试场景**：分页查询系统参数

**前置条件**：系统中存在多条系统参数记录

**测试步骤**：
1. 调用GET /api/v1/system/parameters接口
2. 使用默认分页参数

**预期结果**：
- 返回HTTP状态码200
- 响应体包含分页信息
- list中每条记录包含parameterCode、parameterName、parameterValue等字段
- 敏感参数值可能需要脱敏处理

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：PARAM-QUERY-002

**测试场景**：查询单个参数配置

**前置条件**：系统中存在编码为prescription_validity_days的参数

**测试步骤**：
1. 调用GET /api/v1/system/parameters/prescription_validity_days接口

**预期结果**：
- 返回HTTP状态码200
- 响应体包含该参数的详细信息
- parameterValue字段值为参数值（如"7"）

**测试优先级**：P2（一般功能，建议覆盖）

### 6.2 参数配置更新测试

#### 6.2.1 更新系统参数测试

**测试用例编号**：PARAM-UPDATE-001

**测试场景**：更新系统参数

**前置条件**：系统中存在编码为prescription_validity_days的参数，该参数不是系统只读参数

**测试步骤**：
1. 调用PUT /api/v1/system/parameters/prescription_validity_days接口
2. 请求体包含parameterValue（"10"）

**预期结果**：
- 返回HTTP状态码200
- 数据库中该参数的parameterValue被更新为"10"
- 参数更新日志被记录

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：PARAM-UPDATE-002

**测试场景**：更新只读参数

**前置条件**：系统中存在isReadonly为true的参数

**测试步骤**：
1. 调用PUT /api/v1/system/parameters/readonly_param接口
2. 请求体包含parameterValue（"new_value"）

**预期结果**：
- 返回HTTP状态码403或400
- 错误信息提示该参数为只读
- 参数值未被修改

**测试优先级**：P2（一般功能，建议覆盖）

## 7. 药品管理模块测试用例

药品管理是医院药品管理系统的核心功能之一，本节测试用例覆盖药品的创建、查询、更新、删除等操作。

### 7.1 药品创建测试

#### 7.1.1 正常创建药品测试

**测试用例编号**：DRUG-CREATE-001

**测试场景**：正常创建药品

**前置条件**：当前用户具有创建药品的权限，系统中不存在药品编码为DRUG00001的药品

**测试步骤**：
1. 调用POST /api/v1/drugs接口
2. 请求体包含药品完整信息：
   - genericName（阿莫西林胶囊）
   - specification（0.25g*24粒）
   - dosageForm（胶囊剂）
   - manufacturer（测试制药厂）
   - approvalNumber（国药准字H12345678）
   - drugType（western_medicine）
   - validFrom（2024-01-01）
   - validTo（2026-12-31）
   - retailPrice（25.00）
   - wholesalePrice（20.00）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含新创建药品的完整信息
- drugCode字段由系统自动生成（如DRUG00001）
- status字段值为normal
- 数据库中正确插入药品记录

**边界条件说明**：药品编码由系统自动生成，测试时应验证编码生成规则是否符合需求文档要求（如前缀、流水号等）。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DRUG-CREATE-002

**测试场景**：创建药品时批准文号重复

**前置条件**：系统中已存在批准文号为国药准字H12345678的药品

**测试步骤**：
1. 调用POST /api/v1/drugs接口
2. approvalNumber字段值设置为国药准字H12345678

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误信息提示批准文号已存在
- 数据库中没有新增记录

**边界条件说明**：批准文号是药品的唯一标识，根据需求文档应具有唯一性约束。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DRUG-CREATE-003

**测试场景**：创建药品时有效期起止日期不合理

**前置条件**：当前用户具有创建药品的权限

**测试步骤**：
1. 调用POST /api/v1/drugs接口
2. validFrom设置为2026-01-01，validTo设置为2024-01-01（起止日期颠倒）

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含日期校验错误信息
- 数据库中没有新增记录

**边界条件说明**：有效期起始日期应当早于截止日期，测试时应覆盖各种日期组合情况。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DRUG-CREATE-004

**测试场景**：创建药品时价格字段为负数

**前置条件**：当前用户具有创建药品的权限

**测试步骤**：
1. 调用POST /api/v1/drugs接口
2. retailPrice设置为-25.00

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含价格字段校验错误信息
- 数据库中没有新增记录

**边界条件说明**：价格字段应当为非负数，测试时应覆盖0和负数的边界情况。

**测试优先级**：P1（重要功能，应覆盖）

### 7.2 药品查询测试

#### 7.2.1 分页查询药品列表测试

**测试用例编号**：DRUG-QUERY-001

**测试场景**：分页查询药品列表

**前置条件**：系统中存在多条药品记录

**测试步骤**：
1. 调用GET /api/v1/drugs接口
2. 使用默认分页参数

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含分页信息和药品列表
- list中每条药品记录包含所有字段（除敏感字段外）
- total字段值为药品总记录数

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：DRUG-QUERY-002

**测试场景**：按药品类型筛选查询

**前置条件**：系统中存在多种类型的药品（中药、西药、中成药）

**测试步骤**：
1. 调用GET /api/v1/drugs接口
2. 设置filter参数为drugType:eq:western_medicine

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的drugType都为western_medicine
- total字段值为该类型药品数量

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DRUG-QUERY-003

**测试场景**：按药品名称模糊查询

**前置条件**：系统中存在名称包含"阿莫西林"的药品

**测试步骤**：
1. 调用GET /api/v1/drugs接口
2. 设置keyword参数为"阿莫西林"

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的genericName或tradeName都包含"阿莫西林"
- total字段值为匹配记录数

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DRUG-QUERY-004

**测试场景**：查询药品详情

**前置条件**：系统中存在ID为1的药品

**测试步骤**：
1. 调用GET /api/v1/drugs/1接口

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含该药品的完整信息
- 包含药品分类信息（如果有）

**测试优先级**：P0（核心功能，必须通过）

### 7.3 药品更新测试

#### 7.3.1 正常更新药品测试

**测试用例编号**：DRUG-UPDATE-001

**测试场景**：更新药品价格

**前置条件**：系统中存在ID为1的药品

**测试步骤**：
1. 调用PUT /api/v1/drugs/1接口
2. 请求体包含retailPrice（30.00）、wholesalePrice（24.00）

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含更新后的药品信息
- 数据库中对应记录的retailPrice和wholesalePrice被更新
- updatedAt字段被更新

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DRUG-UPDATE-002

**测试场景**：更新药品状态为停用

**前置条件**：系统中存在ID为1的药品，状态为normal

**测试步骤**：
1. 调用PUT /api/v1/drugs/1接口
2. 请求体包含status（stopped）

**预期结果**：
- 返回HTTP状态码200
- 药品状态变为stopped
- 停用药品应当不能再用于开具处方

**边界条件说明**：停用药品在处方开具时应当被过滤或提示，测试时应验证处方模块是否正确处理停用药品。

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：DRUG-UPDATE-003

**测试场景**：更新药品状态为缺货

**前置条件**：系统中存在ID为1的药品

**测试步骤**：
1. 调用PUT /api/v1/drugs/1接口
2. 请求体包含status（out_of_stock）

**预期结果**：
- 返回HTTP状态码200
- 药品状态变为out_of_stock
- 开具处方时应当提示药品缺货

**测试优先级**：P1（重要功能，应覆盖）

### 7.4 药品删除测试

#### 7.4.1 删除药品测试

**测试用例编号**：DRUG-DELETE-001

**测试场景**：删除药品

**前置条件**：系统中存在ID为100的药品，该药品未被任何处方使用

**测试步骤**：
1. 调用DELETE /api/v1/drugs/100接口

**预期结果**：
- 返回HTTP状态码200或204
- 数据库中该药品记录被删除

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：DRUG-DELETE-002

**测试场景**：删除被处方使用的药品

**前置条件**：系统中存在ID为1的药品，该药品已被处方使用

**测试步骤**：
1. 调用DELETE /api/v1/drugs/1接口

**预期结果**：
- 返回HTTP状态码400或409
- 错误信息提示存在关联数据
- 药品记录未被删除

**边界条件说明**：药品与处方存在外键关联，删除前应当检查是否存在使用该药品的处方记录。

**测试优先级**：P1（重要功能，应覆盖）

## 8. 库存管理模块测试用例

库存管理模块负责药品库存的查询、入库、出库等操作，是保证药品供应的重要模块。

### 8.1 库存查询测试

#### 8.1.1 查询库存列表测试

**测试用例编号**：INVENTORY-QUERY-001

**测试场景**：分页查询库存列表

**前置条件**：系统中存在多条库存记录

**测试步骤**：
1. 调用GET /api/v1/inventory接口
2. 使用默认分页参数

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含分页信息和库存列表
- list中每条记录包含drug、pharmacy等关联信息
- total字段值为库存总记录数

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：INVENTORY-QUERY-002

**测试场景**：按药房筛选库存

**前置条件**：系统中存在多个药房的库存记录

**测试步骤**：
1. 调用GET /api/v1/inventory接口
2. 设置filter参数为pharmacyId:eq:药房ID

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的pharmacyId都为指定药房
- total字段值为该药房库存数量

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：INVENTORY-QUERY-003

**测试场景**：查询库存详情

**前置条件**：系统中存在ID为1的库存记录

**测试步骤**：
1. 调用GET /api/v1/inventory/1接口

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含该库存的完整信息
- 包含药品信息、药房信息、批次信息等

**测试优先级**：P0（核心功能，必须通过）

### 8.2 药品入库测试

#### 8.2.1 正常入库测试

**测试用例编号**：INVENTORY-INBOUND-001

**测试场景**：药品入库操作

**前置条件**：系统中存在ID为1的药品和ID为1的药房

**测试步骤**：
1. 调用POST /api/v1/inventory/inbound接口
2. 请求体包含：
   - drugId（1）
   - pharmacyId（1）
   - batchNumber（20240101001）
   - quantity（1000）
   - unitPrice（20.00）
   - validFrom（2024-01-01）
   - validTo（2026-12-31）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含入库记录信息
- transactionType字段值为inbound
- 库存数量正确增加
- 库存变动记录表新增记录

**边界条件说明**：入库操作需要同时更新库存表和库存变动记录表，应当使用事务保证数据一致性。测试时应验证入库后库存数量是否正确计算。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：INVENTORY-INBOUND-002

**测试场景**：入库时库存超过最高阈值

**前置条件**：系统中存在ID为1的药品，该药品的最高库存阈值为1000，当前库存为500

**测试步骤**：
1. 调用POST /api/v1/inventory/inbound接口
2. quantity设置为800（入库后总量1300，超过阈值1000）

**预期结果**：
- 返回HTTP状态码200（警告）或400（阻止）
- 根据系统配置决定是否允许入库
- 如允许入库，应生成库存积压预警
- 入库记录正确生成

**边界条件说明**：根据需求文档，库存超过最高阈值时应生成积压预警。测试时应验证预警机制是否正确触发。

**测试优先级**：P1（重要功能，应覆盖）

### 8.3 药品出库测试

#### 8.3.1 正常出库测试

**测试用例编号**：INVENTORY-OUTBOUND-001

**测试场景**：药品出库操作

**前置条件**：系统中存在ID为1的库存记录，库存数量为1000

**测试步骤**：
1. 调用POST /api/v1/inventory/outbound接口
2. 请求体包含：
   - drugId（1）
   - pharmacyId（1）
   - batchNumber（20240101001）
   - quantity（100）
   - unitPrice（25.00）
   - referenceId（处方ID，如适用）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含出库记录信息
- transactionType字段值为outbound
- 库存数量正确减少为900
- 库存变动记录表新增记录

**边界条件说明**：出库操作需要验证库存是否充足，如果库存不足应当拒绝出库并返回明确错误。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：INVENTORY-OUTBOUND-002

**测试场景**：出库时库存不足

**前置条件**：系统中存在ID为1的库存记录，库存数量为50

**测试步骤**：
1. 调用POST /api/v1/inventory/outbound接口
2. quantity设置为100（超过库存数量）

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误码30001（库存不足）
- 错误信息明确提示库存不足数量
- 库存记录未被修改
- 出库记录未被创建

**边界条件说明**：库存不足时应明确告知客户端可用的最大出库数量，便于客户端调整出库数量。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：INVENTORY-OUTBOUND-003

**测试场景**：冻结库存不能出库

**前置条件**：系统中存在ID为1的库存记录，isFrozen字段为true，库存数量为1000

**测试步骤**：
1. 调用POST /api/v1/inventory/outbound接口
2. quantity设置为100

**预期结果**：
- 返回HTTP状态码400
- 错误信息提示库存已冻结
- 库存记录未被修改

**边界条件说明**：冻结库存用于处理药品质量问题等特殊情况，冻结状态下不能出库。

**测试优先级**：P1（重要功能，应覆盖）

## 9. 处方管理模块测试用例

处方管理是医院药品管理系统的核心业务模块，涉及处方的创建、审核、查询等操作。

### 9.1 处方创建测试

#### 9.1.1 正常开具处方测试

**测试用例编号**：PRESCRIPTION-CREATE-001

**测试场景**：正常开具处方

**前置条件**：系统中存在有效病人、医生、药品和药房，药品库存充足

**测试步骤**：
1. 调用POST /api/v1/prescriptions接口
2. 请求体包含：
   - patientId（病人ID）
   - departmentId（科室ID）
   - diagnosis（诊断结果）
   - prescriptionDrugs（处方药品列表）：
     - drugId（药品ID）
     - dosage（剂量）
     - dosageUnit（剂量单位）
     - frequency（用药频率）
     - administrationRoute（给药途径）
     - duration（用药天数）
     - quantity（数量）
     - unitPrice（单价）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含创建的处方信息
- prescriptionNumber字段由系统自动生成
- status字段值为pending_review（待审核）
- totalAmount字段值为药品总价之和
- 处方药品记录正确创建
- 处方审核通知推送到药房

**边界条件说明**：处方创建时需要进行多项校验，包括库存校验、剂量校验、禁忌校验等。测试时应覆盖各项校验的正确性。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PRESCRIPTION-CREATE-002

**测试场景**：开具处方时药品库存不足

**前置条件**：系统中存在病人和药品，但药品库存数量为10，处方请求数量为20

**测试步骤**：
1. 调用POST /api/v1/prescriptions接口
2. prescriptionDrugs中设置quantity为20

**预期结果**：
- 返回HTTP状态码400
- 响应体中包含错误码30001（库存不足）
- 错误信息明确提示库存不足数量
- 处方未被创建

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PRESCRIPTION-CREATE-003

**测试场景**：开具处方时使用停用药品

**前置条件**：系统中存在病人和药品，但药品状态为stopped

**测试步骤**：
1. 调用POST /api/v1/prescriptions接口
2. prescriptionDrugs中使用该停用药品

**预期结果**：
- 返回HTTP状态码400
- 错误信息提示药品已停用
- 处方未被创建

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：PRESCRIPTION-CREATE-004

**测试场景**：开具处方时药品已过期

**前置条件**：系统中存在病人和药品，但药品有效期已过

**测试步骤**：
1. 调用POST /api/v1/prescriptions接口
2. prescriptionDrugs中使用该过期药品

**预期结果**：
- 返回HTTP状态码400
- 错误信息提示药品已过期
- 处方未被创建

**测试优先级**：P1（重要功能，应覆盖）

### 9.2 处方查询测试

#### 9.2.1 查询待审核处方列表测试

**测试用例编号**：PRESCRIPTION-QUERY-001

**测试场景**：药房查询待审核处方

**前置条件**：系统中存在多条待审核状态的处方

**测试步骤**：
1. 调用GET /api/v1/prescriptions接口
2. 设置filter参数为status:eq:pending_review
3. 设置当前用户为药房工作人员

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有处方status都为pending_review
- total字段值为待审核处方数量
- 包含病人信息和医生信息

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PRESCRIPTION-QUERY-002

**测试场景**：医生查询自己的处方

**前置条件**：系统中存在该医生的历史处方

**测试步骤**：
1. 调用GET /api/v1/prescriptions接口
2. 设置filter参数为doctorId:eq:医生ID
3. 设置sort参数为created_at，order参数为desc

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有处方都属于该医生
- 按创建时间倒序排列

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：PRESCRIPTION-QUERY-003

**测试场景**：查询处方详情

**前置条件**：系统中存在ID为1的处方

**测试步骤**：
1. 调用GET /api/v1/prescriptions/1接口

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含处方完整信息
- 包含处方药品列表
- 包含审核信息（如已审核）

**测试优先级**：P0（核心功能，必须通过）

### 9.3 处方审核测试

#### 9.3.1 审核通过处方测试

**测试用例编号**：PRESCRIPTION-REVIEW-001

**测试场景**：药房审核通过处方

**前置条件**：系统中存在ID为1的处方，状态为pending_review

**测试步骤**：
1. 调用PUT /api/v1/prescriptions/1/review接口
2. 请求体包含status（reviewed）、reviewComments（审核通过）

**预期结果**：
- 返回HTTP状态码200
- 处方状态变为reviewed
- reviewBy字段设置为审核人ID
- reviewTime字段设置为当前时间
- 审核结果通知推送给医生
- 如果配置为自动出库，触发出库流程

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PRESCRIPTION-REVIEW-002

**测试场景**：药房驳回处方

**前置条件**：系统中存在ID为1的处方，状态为pending_review

**测试步骤**：
1. 调用PUT /api/v1/prescriptions/1/review接口
2. 请求体包含status（rejected）、reviewComments（药品库存不足）

**预期结果**：
- 返回HTTP状态码200
- 处方状态变为rejected
- reviewComments字段包含驳回原因
- 驳回结果通知推送给医生

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PRESCRIPTION-REVIEW-003

**测试场景**：审核已审核的处方

**前置条件**：系统中存在ID为1的处方，状态为reviewed

**测试步骤**：
1. 调用PUT /api/v1/prescriptions/1/review接口
2. 请求体包含status（rejected）

**预期结果**：
- 返回HTTP状态码400
- 错误信息提示处方已审核，不能重复审核
- 处方状态保持不变

**测试优先级**：P1（重要功能，应覆盖）

## 10. 病人管理模块测试用例

病人管理模块负责病人信息的创建、查询、更新等操作。

### 10.1 病人创建测试

#### 10.1.1 正常创建病人测试

**测试用例编号**：PATIENT-CREATE-001

**测试场景**：正常创建病人

**前置条件**：系统中不存在病历号为MRN2024010100001的病人

**测试步骤**：
1. 调用POST /api/v1/patients接口
2. 请求体包含：
   - name（张三）
   - gender（male）
   - age（30）
   - idCard（110101199001011234）
   - phone（13900139000）
   - bloodType（A）

**预期结果**：
- 返回HTTP状态码201或200
- 响应体中包含新创建病人信息
- medicalRecordNumber字段由系统自动生成
- 数据库中正确插入病人记录

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PATIENT-CREATE-002

**测试场景**：创建病人时身份证号重复

**前置条件**：系统中已存在身份证号为110101199001011234的病人

**测试步骤**：
1. 调用POST /api/v1/patients接口
2. idCard字段值设置为110101199001011234

**预期结果**：
- 返回HTTP状态码400
- 错误信息提示身份证号已存在
- 数据库中没有新增记录

**边界条件说明**：身份证号具有唯一性约束，且敏感信息需要加密存储。测试时应验证加密存储的正确性。

**测试优先级**：P1（重要功能，应覆盖）

### 10.2 病人查询测试

#### 10.2.1 查询病人列表测试

**测试用例编号**：PATIENT-QUERY-001

**测试场景**：分页查询病人列表

**前置条件**：系统中存在多条病人记录

**测试步骤**：
1. 调用GET /api/v1/patients接口
2. 使用默认分页参数

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含分页信息和病人列表
- 敏感字段（如idCard、phone）应脱敏显示
- total字段值为病人总记录数

**边界条件说明**：病人敏感信息在列表查询时应进行脱敏处理，如身份证号显示前几位和后几位，中间用星号代替。

**测试优先级**：P0（核心功能，必须通过）

---

**测试用例编号**：PATIENT-QUERY-002

**测试场景**：按姓名模糊查询病人

**前置条件**：系统中存在姓名包含"张"的病人

**测试步骤**：
1. 调用GET /api/v1/patients接口
2. 设置keyword参数为"张"

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的name都包含"张"
- total字段值为匹配记录数

**测试优先级**：P1（重要功能，应覆盖）

---

**测试用例编号**：PATIENT-QUERY-003

**测试场景**：查询病人详情

**前置条件**：系统中存在ID为1的病人

**测试步骤**：
1. 调用GET /api/v1/patients/1接口

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含病人完整信息
- 包含过敏史、既往病史等健康信息
- 包含历史处方记录（如适用）

**测试优先级**：P0（核心功能，必须通过）

## 11. 公共功能测试用例

公共功能模块包括操作日志、在线用户、任务调度等功能，是系统运维和监控的重要组成部分。

### 11.1 操作日志测试

#### 11.1.1 查询操作日志测试

**测试用例编号**：LOG-QUERY-001

**测试场景**：分页查询操作日志

**前置条件**：系统中存在多条操作日志记录

**测试步骤**：
1. 调用GET /api/v1/operation-logs接口
2. 使用默认分页参数

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含分页信息和日志列表
- list中每条记录包含userId、userName、operationType、module、operationContent等字段
- total字段值为日志总记录数

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：LOG-QUERY-002

**测试场景**：按模块查询操作日志

**前置条件**：系统中存在药品模块的操作日志

**测试步骤**：
1. 调用GET /api/v1/operation-logs接口
2. 设置filter参数为module:eq:drugs

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的module都为drugs
- total字段值为药品模块日志数量

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：LOG-QUERY-003

**测试场景**：按时间范围查询操作日志

**前置条件**：系统中存在不同时间的操作日志

**测试步骤**：
1. 调用GET /api/v1/operation-logs接口
2. 设置filter参数为createdAt:gte:2024-01-01&createdAt:lte:2024-01-31

**预期结果**：
- 返回HTTP状态码200
- 返回的list中所有记录的createdAt都在指定时间范围内
- total字段值为该时间范围内的日志数量

**测试优先级**：P2（一般功能，建议覆盖）

### 11.2 在线用户测试

#### 11.2.1 查询在线用户列表测试

**测试用例编号**：ONLINE-QUERY-001

**测试场景**：查询在线用户列表

**前置条件**：系统中存在多个在线用户

**测试步骤**：
1. 调用GET /api/v1/online接口

**预期结果**：
- 返回HTTP状态码200
- 响应体中包含在线用户列表
- 每条记录包含userId、username、loginTime、lastActivityTime等信息
- total字段值为在线用户数量

**测试优先级**：P2（一般功能，建议覆盖）

---

**测试用例编号**：ONLINE-QUERY-002

**测试场景**：强制用户下线

**前置条件**：系统中存在ID为1的在线用户

**测试步骤**：
1. 调用DELETE /api/v1/online/1接口

**预期结果**：
- 返回HTTP状态码200
- 该用户的token从Redis中删除
- 用户下次请求时需要重新登录

**测试优先级**：P2（一般功能，建议覆盖）

## 12. 测试数据准备与清理

### 12.1 测试数据准备策略

在进行单元测试和集成测试前，需要准备必要的测试数据。测试数据应当满足以下要求：

测试数据应具有独立性，每个测试用例应当能够独立运行，不依赖于其他测试用例的执行结果。测试数据应当具有代表性，能够覆盖正常情况和异常情况。测试数据应当具有可重复性，能够在每次测试执行时快速恢复到初始状态。

对于数据库测试，建议使用事务回滚的方式，在每个测试用例执行前开启事务，执行后回滚事务，确保测试数据不会污染数据库。对于需要持久化的测试数据，可以使用测试专用的数据库实例，或在测试完成后手动清理。

### 12.2 Mock数据配置

对于依赖外部服务的测试（如Redis、邮件服务等），应当使用Mock对象替代真实服务。NestJS提供了丰富的测试工具，可以使用Jest的mock功能和@nestjs/testing模块提供的Test utilities来创建Mock对象。

以下是一个使用Mock Redis的示例配置：

```typescript
const mockRedis = {
  get: jest.fn(),
  set: jest.fn(),
  del: jest.fn(),
  exists: jest.fn(),
};

// 在测试模块配置中覆盖Redis提供者
{
  provide: 'REDIS_CLIENT',
  useValue: mockRedis,
}
```

### 12.3 测试环境配置

测试环境应当与生产环境分离，使用独立的数据库和配置。可以通过环境变量指定测试配置，或使用专门的测试配置文件。确保测试环境不会影响生产数据的完整性。

## 13. 测试用例执行与报告

### 13.1 测试执行命令

项目支持以下测试执行命令：

```bash
# 执行所有测试
npm run test

# 监听模式执行测试（文件变更时自动重新运行）
npm run test:watch

# 生成测试覆盖率报告
npm run test:coverage
```

### 13.2 测试覆盖率要求

为确保代码质量，建议设置以下测试覆盖率目标：

- 行覆盖率（Line Coverage）：不低于80%
- 分支覆盖率（Branch Coverage）：不低于70%
- 函数覆盖率（Function Coverage）：不低于80%
- 语句覆盖率（Statement Coverage）：不低于80%

对于核心业务模块（如身份认证、处方管理等），应当达到更高的覆盖率要求。

### 13.3 测试报告查看

测试执行完成后，会在项目根目录下生成coverage目录，其中包含详细的测试覆盖率报告。可以使用浏览器打开coverage/index.html查看可视化报告，分析哪些代码行或分支未被测试覆盖，针对性地补充测试用例。

## 14. 附录

### 14.1 测试用例优先级说明

| 优先级 | 说明 | 覆盖要求 |
| ---- | ---- | ---- |
| P0 | 核心功能，必须通过 | 所有用例必须100%通过 |
| P1 | 重要功能，应覆盖 | 所有用例应覆盖，99%通过 |
| P2 | 一般功能，建议覆盖 | 建议覆盖，95%通过 |

### 14.2 HTTP状态码速查表

| 状态码 | 说明 |
| ---- | ---- |
| 200 | 成功 |
| 201 | 创建成功 |
| 400 | 请求参数错误 |
| 401 | 未授权 |
| 403 | 禁止访问 |
| 404 | 资源不存在 |
| 409 | 资源冲突 |
| 500 | 服务器内部错误 |

### 14.3 常见错误码速查表

| 错误码 | 说明 |
| ---- | ---- |
| 10001 | 用户名或密码错误 |
| 10002 | 验证码错误 |
| 10003 | 账号已锁定 |
| 20001 | 药品编码已存在 |
| 20002 | 药品不存在 |
| 30001 | 库存不足 |
| 30002 | 批次号不存在 |
| 40001 | 处方不存在 |
| 40002 | 处方已审核 |
| 50001 | 字典类型已存在 |
| 50002 | 字典项已存在 |

### 14.4 测试文件命名规范

测试文件应按照以下规范命名，与被测试的源代码文件放在同一目录下：

- 源代码文件：auth.service.ts
- 测试文件：auth.service.spec.ts

每个模块应当有对应的测试文件，至少覆盖Service层的业务逻辑测试。对于重要的Controller，可以添加E2E测试。

### 14.5 参考文献

1. Jest官方文档：https://jestjs.io/docs/getting-started
2. NestJS测试文档：https://docs.nestjs.com/fundamentals/testing
3. Supertest文档：https://github.com/ladjs/supertest
4. 医院药品管理系统需求文档
5. 医院药品管理系统数据库表结构方案
6. 医院药品管理系统Backend API接口文档

---

**文档版本**：1.0.0  
**创建日期**：2024年1月  
**最后更新**：2024年1月  
**文档状态**：草稿
