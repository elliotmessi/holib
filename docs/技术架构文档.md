# 医院药品管理系统 - 技术架构文档

## 1. 文档概述

### 1.1 文档目的
本技术架构文档详细描述医院药品管理系统的技术实现细节，包括后端架构、前端架构、数据库架构、缓存架构、安全架构、部署架构等内容，为系统开发提供技术层面的指导，确保系统采用合理的技术架构，具备良好的可扩展性、可维护性、高性能和安全性。

### 1.2 技术栈总览

| 技术层级 | 技术选型 | 版本要求 | 用途 | 语言/模块 |
| ---- | ---- | ---- | ---- | ---- |
| 后端框架 | NestJS + nest-admin | ^10.0.0 | 基于nest-admin的微服务架构实现 | TypeScript + ESM |
| 数据库 | MySQL | ^8.0 | 主数据库，存储核心业务数据 | - |
| 缓存 | Redis | ^6.0 | 缓存热点数据，提升系统响应速度 | - |
| API网关 | NestJS Gateway | ^10.0.0 | 统一API入口，请求路由、负载均衡 | TypeScript + ESM |
| 身份认证 | JWT | ^9.0.0 | 无状态身份认证（nest-admin自带） | TypeScript + ESM |
| ORM框架 | TypeORM | ^0.3.0 | 数据库访问层（nest-admin自带） | TypeScript + ESM |
| 前端框架（Web/App/小程序） | Unibest | ^3.0.0 | 多端统一开发框架 | TypeScript + ESM |
| 前端框架（后台管理） | UmiJS | ^4.0.0 | 后台管理系统开发框架 | TypeScript + ESM |
| 构建工具 | Vite | ^4.0.0 | 前端构建工具 | - |
| 包管理器 | pnpm | ^7.0.0 | 依赖管理工具 | - |
| 容器化 | Docker | ^20.0.0 | 应用容器化 | - |
| 容器编排 | Docker Compose | ^2.0.0 | 多容器应用编排 | - |

## 2. 后端技术架构

### 2.1 微服务架构设计

#### 2.1.1 服务划分

医院药品管理系统后端基于nest-admin框架构建，采用模块化架构设计，将系统划分为以下核心模块：

| 模块名称 | 主要功能 | 技术实现 | 语言/模块 |
| ---- | ---- | ---- | ---- |
| API网关 | 统一API入口，请求路由、负载均衡、认证授权 | NestJS Gateway（nest-admin自带） | TypeScript + ESM |
| 认证模块 | 用户登录、JWT管理、权限验证 | nest-admin自带 | TypeScript + ESM |
| 用户模块 | RBAC权限管理、角色管理、权限管理 | nest-admin自带 | TypeScript + ESM |
| 字典模块 | 系统字典管理 | nest-admin自带 | TypeScript + ESM |
| 菜单模块 | 后台管理动态菜单 | nest-admin自带 | TypeScript + ESM |
| 药品模块 | 药品信息管理、药品分类管理、药品处方规则设置 | 自定义模块 | TypeScript + ESM |
| 库存模块 | 库存管理、效期管理、库存预警、出入库管理 | 自定义模块 | TypeScript + ESM |
| 病人模块 | 病人信息管理、病人处方历史、过敏史管理 | 自定义模块 | TypeScript + ESM |
| 医院模块 | 医院管理、科室管理、药房管理、系统配置 | 自定义模块 | TypeScript + ESM |
| 处方模块 | 处方开具、处方审核与流转、处方历史管理 | 自定义模块 | TypeScript + ESM |

#### 2.1.2 服务间通信

1. **同步通信**：
   - 使用NestJS内置的HTTP客户端或gRPC进行服务间同步通信
   - 适用于实时性要求高的场景，如处方规则校验、库存校验等

2. **异步通信**：
   - 使用nest-admin自带的事件机制进行服务间异步通信
   - 适用于实时性要求不高的场景，如库存预警、处方审核通知等
   - 消息类型包括：库存更新消息、处方状态变更消息、效期预警消息等

#### 2.1.3 服务注册与发现

- 使用NestJS内置的服务注册与发现机制
- 服务启动时自动注册到服务注册表
- 服务调用时自动从服务注册表获取可用服务实例
- 支持服务健康检查和故障自动切换

### 2.2 后端代码结构

```
backend/
├── nest-admin/              # nest-admin框架主目录
│   ├── src/
│   │   ├── app.module.ts     # 应用模块
│   │   ├── main.ts           # 入口文件
│   │   ├── auth/             # 认证模块（nest-admin自带）
│   │   ├── user/             # 用户模块（nest-admin自带，RBAC权限管理）
│   │   ├── role/             # 角色模块（nest-admin自带）
│   │   ├── permission/       # 权限模块（nest-admin自带）
│   │   ├── dict/             # 字典模块（nest-admin自带）
│   │   ├── menu/             # 菜单模块（nest-admin自带，动态菜单）
│   │   ├── drug/             # 药品模块（自定义）
│   │   ├── drug-category/    # 药品分类模块（自定义）
│   │   ├── drug-rule/        # 药品处方规则模块（自定义）
│   │   ├── inventory/        # 库存模块（自定义）
│   │   ├── inventory-transaction/ # 库存变动记录模块（自定义）
│   │   ├── patient/          # 病人模块（自定义）
│   │   ├── allergy/          # 过敏史模块（自定义）
│   │   ├── hospital/         # 医院模块（自定义）
│   │   ├── department/       # 科室模块（自定义）
│   │   ├── pharmacy/         # 药房模块（自定义）
│   │   ├── system/           # 系统配置模块（自定义）
│   │   ├── prescription/     # 处方模块（自定义）
│   │   └── prescription-drug/ # 处方药品模块（自定义）
│   ├── package.json
│   ├── tsconfig.json
│   ├── nest-cli.json
│   └── .env                 # 环境配置文件
├── docker-compose.yml        # Docker Compose配置文件
├── package.json              # 根package.json
└── pnpm-workspace.yaml       # pnpm工作区配置
```

### 2.3 核心技术实现

#### 2.3.1 身份认证与授权

1. **JWT认证**：
   - 使用jsonwebtoken库生成和验证JWT令牌
   - Token包含用户ID、角色、过期时间等信息
   - Token有效期可配置（默认24小时）

2. **权限控制**：
   - 基于RBAC（角色-权限-用户）模型设计
   - 使用NestJS守卫（Guard）实现权限校验
   - 支持按模块、功能、数据进行细粒度权限控制
   - 权限变更记录可追溯

3. **认证流程**：
   ```mermaid
   sequenceDiagram
       participant Client as 客户端
       participant Gateway as API网关
       participant Auth as 认证服务
       participant Redis as Redis缓存
       
       Client->>Gateway: 发送请求（携带Token）
       Gateway->>Auth: 验证Token
       Auth->>Redis: 检查Token是否存在
       Redis-->>Auth: 返回Token状态
       Auth-->>Gateway: 返回验证结果
       alt Token有效
           Gateway->>Gateway: 路由到对应服务
           Gateway-->>Client: 返回响应
       else Token无效
           Gateway-->>Client: 返回401未授权
       end
   ```

#### 2.3.2 数据库访问

1. **TypeORM配置**：
   - 使用TypeORM作为ORM框架，简化数据库操作
   - 支持PostgreSQL数据库
   - 配置连接池，优化数据库连接管理

2. **实体设计**：
   - 每个服务独立维护自己的实体
   - 实体之间通过外键关联
   - 支持级联操作

3. **查询优化**：
   - 合理使用索引，提高查询性能
   - 使用QueryBuilder构建复杂查询
   - 支持延迟加载和预加载

#### 2.3.3 缓存实现

1. **Redis配置**：
   - 使用ioredis库连接Redis集群
   - 配置主从复制和哨兵机制，提高可用性
   - 设置合理的缓存过期时间

2. **缓存策略**：
   - 热点数据缓存：如药品信息、病人信息等
   - 缓存更新策略：数据变更时自动更新或删除相关缓存
   - 缓存穿透处理：使用布隆过滤器或空值缓存
   - 缓存雪崩处理：使用随机过期时间

3. **缓存使用示例**：
   ```typescript
   // 药品信息缓存
   @Injectable()
   export class DrugCacheService {
     constructor(@InjectRedis() private readonly redis: Redis) {}
     
     async getDrugById(drugId: string): Promise<Drug | null> {
       const cacheKey = `drug:${drugId}`;
       const cachedDrug = await this.redis.get(cacheKey);
       
       if (cachedDrug) {
         return JSON.parse(cachedDrug);
       }
       
       return null;
     }
     
     async setDrug(drug: Drug): Promise<void> {
       const cacheKey = `drug:${drug.id}`;
       await this.redis.set(cacheKey, JSON.stringify(drug), 'EX', 3600); // 缓存1小时
     }
     
     async deleteDrug(drugId: string): Promise<void> {
       const cacheKey = `drug:${drugId}`;
       await this.redis.del(cacheKey);
     }
   }
   ```

#### 2.3.4 消息队列

1. **RabbitMQ配置**：
   - 使用amqplib库连接RabbitMQ集群
   - 配置交换机、队列、绑定关系
   - 支持消息持久化和重试机制

2. **消息类型**：
   - 库存更新消息：药品库存发生变化时发送
   - 处方状态变更消息：处方状态发生变化时发送
   - 效期预警消息：药品临近效期时发送
   - 库存阈值预警消息：药品库存低于阈值时发送

3. **消息消费模式**：
   - 点对点模式：用于一对一通信
   - 发布/订阅模式：用于一对多通信
   - 工作队列模式：用于负载均衡

## 3. 前端技术架构

### 3.1 前端架构总览

| 端类型 | 技术栈 | 构建工具 | 包管理器 | 主要依赖 |
| ---- | ---- | ---- | ---- | ---- |
| Web端 | Unibest + Vue 3 | Vite | pnpm | Vue Router、Pinia、Axios |
| App端 | Unibest + Vue 3 | Vite | pnpm | Vue Router、Pinia、Axios、Cordova |
| 小程序端 | Unibest + Vue 3 | Vite | pnpm | Vue Router、Pinia、Axios、微信小程序SDK |
| 后台管理系统 | UmiJS + React 18 | Vite | pnpm | Umi Router、Dva、Ant Design |

### 3.2 前端代码结构

#### 3.2.1 Web/App/小程序端代码结构

```
app/
├── src/
│   ├── api/                # API请求封装
│   ├── assets/             # 静态资源
│   ├── components/         # 公共组件
│   ├── composables/        # 组合式函数
│   ├── constants/          # 常量定义
│   ├── layouts/            # 布局组件
│   ├── pages/              # 页面组件
│   │   ├── auth/           # 认证页面
│   │   ├── drug/           # 药品页面
│   │   ├── prescription/   # 处方页面
│   │   ├── patient/        # 病人页面
│   │   └── inventory/      # 库存页面
│   ├── router/             # 路由配置
│   ├── stores/             # Pinia状态管理
│   ├── styles/             # 样式文件
│   ├── utils/              # 工具函数
│   ├── App.vue             # 根组件
│   └── main.ts             # 入口文件
├── public/                 # 公共文件
├── .gitignore              # Git忽略配置
├── index.html              # HTML模板
├── package.json            # 依赖配置
├── pnpm-lock.yaml          # pnpm依赖锁文件
├── tsconfig.json           # TypeScript配置
├── tsconfig.node.json      # TypeScript Node配置
└── vite.config.ts          # Vite配置
```

#### 3.2.2 后台管理系统代码结构

```
admin/
├── src/
│   ├── access.ts           # 权限配置
│   ├── app.tsx             # 应用入口
│   ├── components/         # 公共组件
│   ├── e2e/                # 端到端测试
│   ├── locales/            # 国际化配置
│   ├── models/             # 数据模型
│   ├── pages/              # 页面组件
│   │   ├── dashboard/      # 仪表盘
│   │   ├── system/         # 系统配置
│   │   ├── user/           # 用户管理
│   │   ├── role/           # 角色管理
│   │   ├── permission/     # 权限管理
│   │   ├── drug/           # 药品管理
│   │   └── report/         # 报表统计
│   ├── services/           # API服务
│   ├── utils/              # 工具函数
│   └── global.less         # 全局样式
├── .gitignore              # Git忽略配置
├── .umirc.ts               # Umi配置
├── package.json            # 依赖配置
├── pnpm-lock.yaml          # pnpm依赖锁文件
├── tsconfig.json           # TypeScript配置
└── vite.config.ts          # Vite配置
```

### 3.3 核心技术实现

#### 3.3.1 状态管理

1. **Pinia（Vue端）**：
   - 替代Vuex的新一代状态管理库
   - 支持TypeScript
   - 模块化设计，便于维护
   - 支持DevTools

2. **Dva（React端）**：
   - 基于Redux和Redux-saga的状态管理库
   - 简化Redux配置
   - 支持异步处理

3. **状态管理示例**：
   ```typescript
   // Pinia状态管理示例
   import { defineStore } from 'pinia';
   import { ref, computed } from 'vue';
   import { getDrugs, getDrugById } from '@/api/drug';
   
   export const useDrugStore = defineStore('drug', () => {
     // 状态
     const drugs = ref([]);
     const loading = ref(false);
     const error = ref(null);
     
     // 计算属性
     const drugCount = computed(() => drugs.value.length);
     
     // 动作
     const fetchDrugs = async (params) => {
       loading.value = true;
       try {
         const response = await getDrugs(params);
         drugs.value = response.data;
         error.value = null;
       } catch (err) {
         error.value = err.message;
       } finally {
         loading.value = false;
       }
     };
     
     const fetchDrugById = async (id) => {
       loading.value = true;
       try {
         const response = await getDrugById(id);
         return response.data;
       } catch (err) {
         error.value = err.message;
         return null;
       } finally {
         loading.value = false;
       }
     };
     
     return {
       drugs,
       loading,
       error,
       drugCount,
       fetchDrugs,
       fetchDrugById
     };
   });
   ```

#### 3.3.2 API请求封装

1. **Axios配置**：
   - 设置基础URL
   - 配置请求拦截器，添加Token
   - 配置响应拦截器，统一处理错误
   - 配置超时时间（默认30秒）

2. **请求示例**：
   ```typescript
   // Axios配置
   import axios from 'axios';
   import { getToken, removeToken } from '@/utils/auth';
   import router from '@/router';
   
   const service = axios.create({
     baseURL: import.meta.env.VITE_API_BASE_URL,
     timeout: 30000
   });
   
   // 请求拦截器
   service.interceptors.request.use(
     (config) => {
       const token = getToken();
       if (token) {
         config.headers.Authorization = `Bearer ${token}`;
       }
       return config;
     },
     (error) => {
       return Promise.reject(error);
     }
   );
   
   // 响应拦截器
   service.interceptors.response.use(
     (response) => {
       const res = response.data;
       if (res.code !== 200) {
         if (res.code === 401) {
           // Token过期或无效，清除Token并跳转到登录页
           removeToken();
           router.push('/auth/login');
         }
         return Promise.reject(new Error(res.message || 'Error'));
       } else {
         return res;
       }
     },
     (error) => {
       return Promise.reject(error);
     }
   );
   
   export default service;
   ```

#### 3.3.3 路由配置

1. **Vue Router配置**：
   - 支持动态路由
   - 支持路由守卫，实现权限控制
   - 支持嵌套路由
   - 支持路由懒加载

2. **路由示例**：
   ```typescript
   // Vue Router配置
   import { createRouter, createWebHistory } from 'vue-router';
   import { useUserStore } from '@/stores/user';
   
   const routes = [
     {
       path: '/',
       redirect: '/dashboard'
     },
     {
       path: '/auth',
       component: () => import('@/layouts/AuthLayout.vue'),
       children: [
         {
           path: 'login',
           name: 'login',
           component: () => import('@/pages/auth/Login.vue')
         },
         {
           path: 'forgot-password',
           name: 'forgot-password',
           component: () => import('@/pages/auth/ForgotPassword.vue')
         }
       ]
     },
     {
       path: '/',
       component: () => import('@/layouts/MainLayout.vue'),
       meta: { requiresAuth: true },
       children: [
         {
           path: 'dashboard',
           name: 'dashboard',
           component: () => import('@/pages/Dashboard.vue')
         },
         {
           path: 'drugs',
           name: 'drugs',
           component: () => import('@/pages/drug/DrugList.vue')
         },
         {
           path: 'prescriptions',
           name: 'prescriptions',
           component: () => import('@/pages/prescription/PrescriptionList.vue')
         }
       ]
     }
   ];
   
   const router = createRouter({
     history: createWebHistory(import.meta.env.BASE_URL),
     routes
   });
   
   // 路由守卫
   router.beforeEach((to, from, next) => {
     const userStore = useUserStore();
     const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
     
     if (requiresAuth && !userStore.isLoggedIn) {
       next('/auth/login');
     } else {
       next();
     }
   });
   
   export default router;
   ```

## 4. 数据库架构

### 4.1 PostgreSQL配置

1. **主从复制**：
   - 配置PostgreSQL主从复制，实现数据自动同步
   - 主库负责写操作，从库负责读操作
   - 支持故障自动切换

2. **连接池配置**：
   - 配置pgBouncer作为连接池，优化数据库连接管理
   - 设置合理的连接池大小（默认100）
   - 配置连接超时时间

3. **索引优化**：
   - 为频繁查询的字段创建索引
   - 合理设计复合索引
   - 定期使用VACUUM ANALYZE命令维护索引

### 4.2 数据库迁移

1. **TypeORM迁移**：
   - 使用TypeORM迁移工具管理数据库结构变更
   - 每个服务独立维护自己的迁移文件
   - 支持向上迁移（migrate）和向下迁移（rollback）

2. **迁移流程**：
   ```
   # 生成迁移文件
   npm run typeorm migration:generate -- -n MigrationName
   
   # 执行迁移
   npm run typeorm migration:run
   
   # 回滚迁移
   npm run typeorm migration:revert
   ```

## 5. 缓存架构

### 5.1 Redis集群配置

1. **主从复制**：
   - 配置Redis主从复制，提高数据可用性
   - 主库负责写操作，从库负责读操作

2. **哨兵机制**：
   - 配置Redis哨兵，实现主库故障自动切换
   - 哨兵节点监控主从节点状态
   - 当主库故障时，自动选举新的主库

3. **集群模式**：
   - 配置Redis集群，支持数据分片
   - 每个分片包含主从节点
   - 支持水平扩展

### 5.2 缓存使用场景

| 缓存类型 | 使用场景 | 过期时间 |
| ---- | ---- | ---- |
| 药品信息缓存 | 药品查询、处方开具时 | 1小时 |
| 病人信息缓存 | 病人信息查询、处方开具时 | 1小时 |
| 库存信息缓存 | 库存查询、处方开具时 | 5分钟 |
| 权限缓存 | 权限验证时 | 24小时 |
| Token缓存 | JWT Token验证时 | 24小时 |
| 验证码缓存 | 登录验证码验证时 | 5分钟 |

## 6. 安全架构

### 6.1 数据安全

1. **数据加密**：
   - 敏感数据（如病人身份证号、手机号）使用AES-256加密算法存储
   - 密码使用bcrypt算法进行哈希处理，加盐存储
   - 传输数据采用HTTPS协议

2. **数据备份**：
   - 配置定期备份策略，包括全量备份和增量备份
   - 备份数据存储在安全的位置
   - 定期测试数据恢复流程

### 6.2 应用安全

1. **输入验证**：
   - 所有输入参数进行严格校验，防止SQL注入、XSS攻击等
   - 使用NestJS管道（Pipe）实现输入验证
   - 前端和后端双重验证

2. **CSRF防护**：
   - 实现CSRF令牌机制，防止跨站请求伪造
   - 为每个请求生成唯一的CSRF令牌

3. **防止暴力破解**：
   - 登录失败次数限制（默认5次）
   - 超过限制后账号锁定（默认30分钟）
   - 验证码机制，防止机器人攻击

### 6.3 网络安全

1. **防火墙配置**：
   - 配置防火墙，限制访问来源
   - 只开放必要的端口
   - 配置IP白名单

2. **DDoS防护**：
   - 配置DDoS防护机制，防止分布式拒绝服务攻击
   - 限制单个IP的请求频率

## 7. 部署架构

### 7.1 Docker容器化

1. **Dockerfile示例**：
   ```dockerfile
   # 后端服务Dockerfile
   FROM node:18-alpine
   
   WORKDIR /app
   
   COPY package*.json ./
   
   RUN npm install -g pnpm && pnpm install
   
   COPY . .
   
   RUN pnpm run build
   
   EXPOSE 3000
   
   CMD ["pnpm", "run", "start:prod"]
   ```

2. **Docker Compose配置**：
   ```yaml
   version: '3.8'
   
   services:
     # MySQL主库
     mysql-master:
       image: mysql:8.0
       environment:
         MYSQL_DATABASE: hospital_db
         MYSQL_USER: admin
         MYSQL_PASSWORD: password
         MYSQL_ROOT_PASSWORD: password
       volumes:
         - mysql-master-data:/var/lib/mysql
       ports:
         - "3306:3306"
       command: --default-authentication-plugin=mysql_native_password --server-id=1 --log-bin=mysql-bin --binlog-format=ROW
       restart: always
     
     # MySQL从库
     mysql-slave:
       image: mysql:8.0
       environment:
         MYSQL_DATABASE: hospital_db
         MYSQL_USER: admin
         MYSQL_PASSWORD: password
         MYSQL_ROOT_PASSWORD: password
       volumes:
         - mysql-slave-data:/var/lib/mysql
       ports:
         - "3307:3306"
       command: --default-authentication-plugin=mysql_native_password --server-id=2 --log-bin=mysql-bin --binlog-format=ROW --relay-log=mysql-relay-bin --read-only=1
       restart: always
       depends_on:
         - mysql-master
     
     # Redis主库
     redis-master:
       image: redis:6-alpine
       command: redis-server --requirepass password --appendonly yes
       volumes:
         - redis-master-data:/data
       ports:
         - "6379:6379"
       restart: always
     
     # Redis从库
     redis-slave:
       image: redis:6-alpine
       command: redis-server --slaveof redis-master 6379 --requirepass password --masterauth password --appendonly yes
       volumes:
         - redis-slave-data:/data
       ports:
         - "6380:6379"
       restart: always
       depends_on:
         - redis-master
     
     # RabbitMQ
     rabbitmq:
       image: rabbitmq:3.9-management-alpine
       environment:
         RABBITMQ_DEFAULT_USER: admin
         RABBITMQ_DEFAULT_PASS: password
       volumes:
         - rabbitmq-data:/var/lib/rabbitmq
       ports:
         - "5672:5672"
         - "15672:15672"
       restart: always
     
     # API网关
     api-gateway:
       build: ./backend/api-gateway
       ports:
         - "3000:3000"
       environment:
         NODE_ENV: production
         DATABASE_URL: mysql://admin:password@mysql-master:3306/hospital_db
         REDIS_URL: redis://:password@redis-master:6379
       restart: always
       depends_on:
         - mysql-master
         - redis-master
     
     # 药品服务
     drug-service:
       build: ./backend/drug-service
       ports:
         - "3001:3001"
       environment:
         NODE_ENV: production
         DATABASE_URL: mysql://admin:password@mysql-master:3306/hospital_db
         REDIS_URL: redis://:password@redis-master:6379
       restart: always
       depends_on:
         - mysql-master
         - redis-master
     
     # 其他服务配置类似...
     
     # Web端
     web:
       build: ./app
       ports:
         - "80:80"
       restart: always
       depends_on:
         - api-gateway
     
     # 后台管理系统
     admin:
       build: ./admin
       ports:
         - "81:80"
       restart: always
       depends_on:
         - api-gateway
   
   volumes:
     mysql-master-data:
     mysql-slave-data:
     redis-master-data:
     redis-slave-data:
   ```

### 7.2 部署流程

1. **开发环境部署**：
   - 使用Docker Compose启动所有服务
   - 运行命令：`pnpm run docker:dev`

2. **测试环境部署**：
   - 使用Docker Compose启动所有服务
   - 运行命令：`pnpm run docker:test`

3. **生产环境部署**：
   - 使用Kubernetes进行集群部署
   - 支持自动扩缩容
   - 支持滚动更新

## 8. 开发流程

### 8.1 包管理

1. **pnpm配置**：
   - 使用pnpm作为包管理器，提高依赖安装速度
   - 配置pnpm工作区，统一管理所有服务的依赖

2. **依赖安装**：
   ```
   # 安装所有依赖
   pnpm install
   
   # 安装单个服务的依赖
   pnpm install --filter service-name
   ```

### 8.2 构建工具

1. **Vite配置**：
   - 使用Vite作为构建工具，提高构建速度
   - 配置多环境构建
   - 支持热更新

2. **构建命令**：
   ```
   # 构建所有服务
   pnpm run build
   
   # 构建单个服务
   pnpm run build --filter service-name
   ```

### 8.3 开发命令

| 命令 | 用途 |
| ---- | ---- |
| pnpm run dev | 启动开发服务器 |
| pnpm run build | 构建生产版本 |
| pnpm run lint | 运行ESLint检查 |
| pnpm run typecheck | 运行TypeScript类型检查 |
| pnpm run test | 运行测试 |
| pnpm run docker:dev | 启动开发环境Docker容器 |
| pnpm run docker:test | 启动测试环境Docker容器 |

## 9. 监控与日志

### 9.1 系统监控

1. **Prometheus监控**：
   - 配置Prometheus监控系统性能指标
   - 监控指标包括：CPU使用率、内存使用率、磁盘使用率、网络流量等
   - 监控服务响应时间、错误率等业务指标

2. **Grafana可视化**：
   - 使用Grafana可视化监控数据
   - 创建监控仪表盘，展示关键指标
   - 配置告警规则，当指标超过阈值时发送告警

### 9.2 日志管理

1. **Winston日志**：
   - 使用Winston库记录系统日志
   - 支持多级别日志（debug、info、warn、error）
   - 支持日志轮转，定期清理旧日志

2. **ELK Stack**：
   - 配置ELK Stack（Elasticsearch、Logstash、Kibana）收集和分析日志
   - 支持日志查询、过滤、统计等功能
   - 支持日志可视化

## 10. 结论

本技术架构文档详细描述了医院药品管理系统的技术实现细节，包括后端架构、前端架构、数据库架构、缓存架构、安全架构、部署架构等内容。该技术架构遵循了模块化、微服务、前后端分离、高性能、安全性优先等设计原则，确保系统具备良好的可扩展性、可维护性、高性能和安全性。

通过该技术架构，系统能够实现：
- 支持10+医院、100+医生的业务需求
- 提供高性能、高可用的服务
- 确保数据安全和操作安全
- 支持多终端访问（Web、App、小程序、后台管理系统）
- 便于未来功能扩展和性能扩展
- 提供完善的监控和日志管理

该技术架构为系统开发提供了详细的技术指导，确保系统能够按时、按质、按量完成开发，满足用户的需求。